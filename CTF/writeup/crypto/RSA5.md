---
sort: 4
---

# RSA5

## 题面

此题涉及`WienerAttack`攻击, 题目如下:

```python
import hashlib
import sympy
import gmpy2
from Crypto.Util.number import *

flag = 'GWHT{************}'

flag1 = flag[:19].encode()
flag2 = flag[19:].encode()
assert(len(flag) == 38)

P1 = getPrime(1038)
P2 = sympy.nextprime(P1)
assert(P2 - P1 < 1000)

Q1 = getPrime(512)
Q2 = sympy.nextprime(Q1)

N1 = P1 * P1 * Q1
N2 = P2 * P2 * Q2

E1 = getPrime(1024)
E2 = sympy.nextprime(E1)

m1 = bytes_to_long(flag1)
m2 = bytes_to_long(flag2)

c1 = pow(m1, E1, N1)
c2 = pow(m2, E2, N2)


output = open('secret', 'w')
output.write('N1=' + str(N1) + '\n')
output.write('c1=' + str(c1) + '\n')
output.write('E1=' + str(E1) + '\n')
output.write('N2=' + str(N2) + '\n')
output.write('c2=' + str(c2) + '\n')
output.write('E2=' + str(E2) + '\n')
output.close()

# N1=60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868190554644983911078936369464590301246394586190666760362763580192139772729890492729488892169933099057105842090125200369295070365451134781912223048179092058016446222199742919885472867511334714233086339832790286482634562102936600597781342756061479024744312357407750731307860842457299116947352106025529309727703385914891200109853084742321655388368371397596144557614128458065859276522963419738435137978069417053712567764148183279165963454266011754149684758060746773409666706463583389316772088889398359242197165140562147489286818190852679930372669254697353483887004105934649944725189954685412228899457155711301864163839538810653626724347
# c1=55094296873556883585060020895253176070835143350249581136609315815308788255684072804968957510292559743192424646169207794748893753882418256401223641287546922358162629295622258913168323493447075410872354874300793298956869374606043622559405978242734950156459436487837698668489891733875650048466360950142617732135781244969524095348835624828008115829566644654403962285001724209210887446203934276651265377137788183939798543755386888532680013170540716736656670269251318800501517579803401154996881233025210176293554542024052540093890387437964747460765498713092018160196637928204190194154199389276666685436565665236397481709703644555328705818892269499380797044554054118656321389474821224725533693520856047736578402581854165941599254178019515615183102894716647680969742744705218868455450832
# E1=125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820423103
# N2=60143104944034567859993561862949071559877219267755259679749062284763163484947626697494729046430386559610613113754453726683312513915610558734802079868195633647431732875392121458684331843306730889424418620069322578265236351407591029338519809538995249896905137642342435659572917714183543305243715664380787797562011006398730320980994747939791561885622949912698246701769321430325902912003041678774440704056597862093530981040696872522868921139041247362592257285423948870944137019745161211585845927019259709501237550818918272189606436413992759328318871765171844153527424347985462767028135376552302463861324408178183842139330244906606776359050482977256728910278687996106152971028878653123533559760167711270265171441623056873903669918694259043580017081671349232051870716493557434517579121
# c2=39328446140156257571484184713861319722905864197556720730852773059147902283123252767651430278357950872626778348596897711320942449693270603776870301102881405303651558719085454281142395652056217241751656631812580544180434349840236919765433122389116860827593711593732385562328255759509355298662361508611531972386995239908513273236239858854586845849686865360780290350287139092143587037396801704351692736985955152935601987758859759421886670907735120137698039900161327397951758852875291442188850946273771733011504922325622240838288097946309825051094566685479503461938502373520983684296658971700922069426788236476575236189040102848418547634290214175167767431475003216056701094275899211419979340802711684989710130215926526387138538819531199810841475218142606691152928236362534181622201347
# E2=125932919717342481428108392434488550259190856475011752106073050593074410065655587870702051419898088541590032209854048032649625269856337901048406066968337289491951404384300466543616578679539808215698754491076340386697518948419895268049696498272031094236309803803729823608854215226233796069683774155739820425393

```

## 思路

通过观察代码, 发现题目生成了相邻的`P1, P2`与`Q1, Q2`, 再计算

```
N1 = P1 * P1 * Q1
N2 = P2 * P2 * Q2
```

再随机生成`E1,E2`作为公钥, 用`N1,N2`为模数分别 RSA 加密 flag 的前后半段得到`c1, c2`  
由于`P1, P2`相当接近, 其差值小于 1000, 因此$\frac{N1}{N2}\approx\frac{Q1}{Q2}$, 而且二者的比值是相当接近的, 因此由 Wiener Attack 定理可知, 只要依次展开$\frac{N1}{N2}$, 就能精确找到`Q1`和`Q2`, 于是求解脚本如下

```python
import sympy
import gmpy2
from Crypto.Util.number import *


def continuedFra(a,b):
    '''连分数展开'''
    res = []
    while b:
        res += [a//b]
        a,b = b,a%b
    return res


def Simplify(each):
    '''将连分数序列合并为a/b的形式'''
    a = 0
    b = 1
    for x in each[::-1]:
        a,b = b,x*b+a

    return (a,b)


def simp1(res):
    '''求解每个连分数子序列的分数形式'''
    ret = []
    for i in range(1,len(res)):
        ret.append(Simplify(res[:i]))

    return ret


def winner(a,b):
    res = continuedFra(a,b)
    for (q2,q1) in simp1(res):
        if q1 == 0:
            continue
        if N1 % q1 ==0 and q1!=1:
            return q1
    return 0

q1 = winner(N1,N2)

p1 = gmpy2.iroot(N1//q1,2)[0]
p2 = gmpy2.next_prime(p1)
q2 = gmpy2.next_prime(q1)

phi1 = p1 * (q1-1) * (p1-1)
phi2 = p2 * (q2-1) * (p2-1)

d1 = gmpy2.invert(E1,phi1)
d2 = gmpy2.invert(E2,phi2)

m1 = long_to_bytes(pow(c1,d1,N1))
m2 = long_to_bytes(pow(c2,d2,N2))
print(m1+m2)
```
